const express = require('express');
const fs = require('fs');
const path = require('path');
// const chalk = require('chalk'); <--- REMOVIDO: Ser√° carregado dinamicamente
const multer = require('multer');

// ‚¨ÖÔ∏è NOVO: Imports para Socket.IO
const http = require('http'); 
const { Server } = require('socket.io'); 

// Vari√°vel que ir√° segurar a refer√™ncia correta do chalk
let chalk; 

const app = express();
const PORT = 4000;

// ‚¨ÖÔ∏è NOVO: Cria o servidor HTTP e conecta o Socket.IO
const server = http.createServer(app);
const io = new Server(server, {
    // Permite que o frontend se conecte (necess√°rio se estiver em portas diferentes)
    cors: {
        origin: "*", 
        methods: ["GET", "POST", "PUT", "DELETE"]
    }
});


// ----------------------------------------------------
// Configura√ß√£o do Multer (Corre√ß√£o de erro anterior)
// ----------------------------------------------------
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const uploadPath = path.join(__dirname, 'uploads');
        // Usando o fs.promises.mkdir para suportar async/await
        if (!fs.existsSync(uploadPath)) {
            fs.mkdirSync(uploadPath);
        }
        cb(null, uploadPath);
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, uniqueSuffix + '-' + file.originalname);
    }
});
const upload = multer({ storage: storage });

app.use((req, res, next) => {
    if (req.method === 'POST' && (req.url === '/tasks-with-file' || req.url.startsWith('/tasks/'))) {
        next(); 
    } else {
        express.json()(req, res, next);
    }
});

app.use(express.static(path.join(__dirname)));
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Log de conex√£o do Socket.IO
io.on('connection', (socket) => {
    // Usando 'chalk' no lugar de 'chalkInstance'
    console.log(chalk.magenta('üë§ Novo usu√°rio conectado via Socket.IO'));
});

// ----------------------------------------------------
// ROTAS EXISTENTES
// ----------------------------------------------------

// GET /tasks
app.get('/tasks', (req, res) => {
    fs.readFile('pendencias.json', 'utf8', (err, data) => {
        if (err) {
            // Usando 'chalk'
            console.error(chalk.red('‚ùå ERRO ao ler o arquivo de pend√™ncias:'), err.message);
            if (err.code === 'ENOENT') {
                return res.json([]);
            }
            return res.status(500).json({ error: 'Erro ao ler o arquivo' });
        }
        res.json(JSON.parse(data || '[]'));
        // Usando 'chalk'
        console.log(chalk.green('üì¶ Pend√™ncias carregadas!'));
    });
});

// DELETE /tasks/:name
app.delete('/tasks/:name', (req, res) => {
    const taskName = req.params.name;
    fs.readFile('pendencias.json', 'utf8', (err, data) => {
        if (err) {
            // Usando 'chalk'
            console.error(chalk.red('‚ùå ERRO ao ler o arquivo para deletar:'), err.message);
            return res.status(500).json({ error: 'Erro ao ler o arquivo' });
        }
        let tasks = JSON.parse(data || '[]');
        const initialLength = tasks.length;
        tasks = tasks.filter(task => task.name !== taskName);
        
        fs.writeFile('pendencias.json', JSON.stringify(tasks, null, 2), (err) => {
            if (err) {
                // Usando 'chalk'
                console.error(chalk.red('‚ùå ERRO ao deletar a tarefa:'), err.message);
                return res.status(500).json({ error: 'Erro ao deletar a tarefa' });
            }
            if (tasks.length < initialLength) {
                // Usando 'chalk'
                console.log(chalk.yellow(`üóëÔ∏è Pend√™ncia "${taskName}" deletada!`));
                io.emit('task_deleted', taskName); // ‚¨ÖÔ∏è EMITE
            } else {
                 // Usando 'chalk'
                 console.log(chalk.red(`‚ö†Ô∏è Tentativa de deletar pend√™ncia n√£o encontrada: "${taskName}"`));
            }
            res.status(204).send();
        });
    });
});

// DELETE /tasks/clear-all
app.delete('/tasks/clear-all', (req, res) => {
    fs.writeFile('pendencias.json', JSON.stringify([], null, 2), (err) => {
        if (err) {
            // Usando 'chalk'
            console.error(chalk.red('‚ùå ERRO ao limpar todas as pend√™ncias:'), err.message);
            return res.status(500).json({ error: 'Erro ao atualizar o arquivo' });
        }
        res.status(204).send();
        // Usando 'chalk'
        console.log(chalk.magenta('‚ú® Todas as Pend√™ncias Limpas!'));
        io.emit('tasks_cleared'); // ‚¨ÖÔ∏è EMITE
    });
});

// PUT /tasks/:name (usado para concluir/reabrir)
app.put('/tasks/:name', (req, res) => {
    const taskName = req.params.name;
    const updatedTaskData = req.body;

    fs.readFile('pendencias.json', 'utf8', (err, data) => {
        if (err) {
            // Usando 'chalk'
            console.error(chalk.red('‚ùå ERRO ao ler o arquivo para atualizar:'), err.message);
            return res.status(500).json({ error: 'Erro ao ler o arquivo' });
        }
        let tasks = JSON.parse(data || '[]');
        let taskFound = false;
        let finalUpdatedTask = null;

        tasks = tasks.map(task => {
            if (task.name === taskName) {
                taskFound = true;
                // Mescla os dados existentes com os dados atualizados (como 'completed: true')
                finalUpdatedTask = { ...task, ...updatedTaskData }; 
                return finalUpdatedTask;
            }
            return task;
        });

        fs.writeFile('pendencias.json', JSON.stringify(tasks, null, 2), (err) => {
            if (err) {
                // Usando 'chalk'
                console.error(chalk.red('‚ùå ERRO ao atualizar a tarefa:'), err.message);
                return res.status(500).json({ error: 'Erro ao atualizar a tarefa' });
            }
            if (taskFound) {
                // Usando 'chalk'
                console.log(chalk.blue(`‚úÖ Pend√™ncia "${taskName}" atualizada!`));
                io.emit('task_updated', finalUpdatedTask); // ‚¨ÖÔ∏è EMITE
            } else {
                // Usando 'chalk'
                console.log(chalk.red(`‚ö†Ô∏è Tentativa de atualizar pend√™ncia n√£o encontrada: "${taskName}"`));
            }
            res.json(finalUpdatedTask);
        });
    });
});


// POST /tasks-with-file (Adicionar nova pend√™ncia)
app.post('/tasks-with-file', upload.array('attachments', 10), (req, res) => {
    const files = req.files; 
    const body = req.body;

    const attachments = files ? files.map(file => ({
        path: `/uploads/${file.filename}`,
        filename: file.originalname 
    })) : [];

    const newTask = {
        name: body.taskName,
        city: body.cityName,
        requester: body.requesterName,
        completed: false,
        timestamp: new Date().toISOString(),
        attachments: attachments 
    };

    fs.readFile('pendencias.json', 'utf8', (err, data) => {
        if (err && err.code !== 'ENOENT') {
            // Usando 'chalk'
            console.error(chalk.red('‚ùå ERRO ao ler o arquivo para adicionar:'), err.message);
            return res.status(500).json({ error: 'Erro ao ler o arquivo' });
        }
        const tasks = JSON.parse(data || '[]');
        tasks.push(newTask);
        
        fs.writeFile('pendencias.json', JSON.stringify(tasks, null, 2), (err) => {
            if (err) {
                // Usando 'chalk'
                console.error(chalk.red('‚ùå ERRO ao salvar a tarefa:'), err.message);
                return res.status(500).json({ error: 'Erro ao salvar a tarefa' });
            }
            
            io.emit('task_created', newTask); // ‚¨ÖÔ∏è EMITE

            res.status(201).json(newTask);
            // Usando 'chalk'
            console.log(chalk.cyan(`‚ûï Nova Pend√™ncia Adicionada: ${newTask.name} (${newTask.city}) com ${attachments.length} Anexo(s)`));
        });
    });
});

// POST /tasks/:name/attach (Anexar arquivo)
app.post('/tasks/:name/attach', upload.array('attachments', 10), (req, res) => {
    const taskName = req.params.name;
    const files = req.files; 

    const newAttachments = files.map(file => ({
        path: `/uploads/${file.filename}`,
        filename: file.originalname
    }));


    fs.readFile('pendencias.json', 'utf8', (err, data) => {
        if (err) {
            // Usando 'chalk'
            console.error(chalk.red('‚ùå ERRO ao ler o arquivo para anexar:'), err.message);
            return res.status(500).json({ error: 'Erro ao ler o arquivo' });
        }
        let tasks = JSON.parse(data || '[]');
        let taskFound = false;
        let updatedTask = null;

        tasks = tasks.map(task => {
            if (task.name === taskName) {
                taskFound = true;
                const existingAttachments = task.attachments || [];
                task.attachments = [...existingAttachments, ...newAttachments];
                updatedTask = task;
                return task;
            }
            return task;
        });

        if (!taskFound) {
            return res.status(404).json({ error: 'Pend√™ncia n√£o encontrada.' });
        }

        fs.writeFile('pendencias.json', JSON.stringify(tasks, null, 2), (err) => {
            if (err) {
                // Usando 'chalk'
                console.error(chalk.red('‚ùå ERRO ao anexar arquivo √† tarefa:'), err.message);
                return res.status(500).json({ error: 'Erro ao salvar o anexo.' });
            }
            
            io.emit('task_updated', updatedTask); // ‚¨ÖÔ∏è EMITE

            // Usando 'chalk'
            console.log(chalk.blue(`üìé ${newAttachments.length} anexo(s) adicionados √† pend√™ncia "${taskName}"`));
            res.status(200).json(updatedTask);
        });
    });
});

// ----------------------------------------------------------------------------------
// NOVO: Fun√ß√£o ass√≠ncrona para iniciar o servidor e carregar o CHALK
// ----------------------------------------------------------------------------------

async function startServer() {
    try {
        // Carrega o chalk (ESM) dinamicamente dentro do CommonJS
        const chalkModule = await import('chalk');
        // Pega a refer√™ncia correta (CommonJS geralmente usa .default)
        chalk = chalkModule.default || chalkModule; 

        // ‚¨ÖÔ∏è MUDAN√áA: Usa server.listen
        server.listen(PORT, () => {
            // Usa 'chalk' ap√≥s ter sido carregado
            console.log(chalk.green(`\nüöÄ Servidor KSS MOTOS rodando em http://localhost:${PORT}\n`));
        });
    } catch (error) {
        console.error("‚ùå ERRO FATAL ao iniciar o servidor (Falha ao carregar o Chalk):", error);
    }
}

// Inicia o servidor
startServer();